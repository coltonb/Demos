<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, shrink-to-fit=no"
    />
    <link rel="icon" type="image/x-icon" href="img/favicon.ico" />
    <link rel="stylesheet" href="css/style.css" />
    <script type="text/javascript" src="js/dat.gui.min.js"></script>
    <script type="text/javascript" src="js/stats.min.js"></script>
    <title>Cellular</title>
  </head>

  <body>
    <div id="sidebar"></div>
    <div id="container">
      <canvas id="canvas" width="250" height="250"></canvas>
    </div>
    <script type="text/javascript" src="js/cellular.js"></script>
    <script type="text/javascript" src="js/simulations/conway.js"></script>
    <script type="text/javascript" src="js/simulations/move.js"></script>
    <script type="text/javascript" src="js/simulations/freeze.js"></script>
    <script type="text/javascript" src="js/simulations/seeds.js"></script>
    <script type="text/javascript" src="js/simulations/mirage.js"></script>
    <script
      type="text/javascript"
      src="js/simulations/brians_brain.js"
    ></script>
    <script type="text/javascript" src="js/simulations/water.js"></script>
    <script type="text/javascript">
      const canvas = document.querySelector('#canvas');
      const simulations = [
        conwaySimulation(),
        moveSimulation(),
        freezeSimulation(),
        seedsSimulation(),
        briansBrainSimulation(),
        mirageSimulation(),
        waterSimulation()
      ];
      const cellSpace = new CellSpace(canvas, simulations, simulations[6]);

      let controls = {
        run: true,
        mouseDown: false,
        mouseState: 1,
        currentSimulationIndex: cellSpace.currentSimulationName,
        Cell: null,
        'Brush Size': 2,
        step: () => {
          cellSpace.step();
        },
        fillDensity: 0.1,
        clear: () => {
          cellSpace.clear();
        },
        fill: () => {
          cellSpace.fill(controls.fillDensity);
        },
        toggleCell: (x, y) => {
          for (
            let newY = y - controls['Brush Size'];
            newY < y + controls['Brush Size'];
            newY += 1
          ) {
            for (
              let newX = x - controls['Brush Size'];
              newX < x + controls['Brush Size'];
              newX += 1
            ) {
              if (cellSpace.isInBounds(newX, newY)) {
                cellSpace
                  .getCell(newX, newY)
                  .forceState(
                    JSON.parse(
                      JSON.stringify(
                        cellSpace.currentSimulation.states[controls.Cell]
                      )
                    )
                  );
              }
            }
          }
        },
        setSimulation: name => {
          cellSpace.setCurrentSimulation(name);
          controls.fill();
          const states = Object.keys(cellSpace.currentSimulation.states);
          controls.Cell = states[0];
          controls.stateSelection = controls.stateSelection.options(states);
        }
      };

      canvas.addEventListener('mousedown', e => {
        controls.mouseDown = true;
        const canvasBoundingRect = canvas.getBoundingClientRect();
        const x = Math.floor(
          canvas.getAttribute('width') *
            ((e.clientX - canvasBoundingRect.x) / canvasBoundingRect.width)
        );
        const y = Math.floor(
          canvas.getAttribute('height') *
            ((e.clientY - canvasBoundingRect.y) / canvasBoundingRect.height)
        );
        controls.mouseState = controls.toggleCell(x, y);
      });

      window.addEventListener('mouseup', () => (controls.mouseDown = false));

      canvas.addEventListener('mousemove', e => {
        if (controls.mouseDown) {
          const canvasBoundingRect = canvas.getBoundingClientRect();
          const x = Math.floor(
            canvas.getAttribute('width') *
              ((e.clientX - canvasBoundingRect.x) / canvasBoundingRect.width)
          );
          const y = Math.floor(
            canvas.getAttribute('height') *
              ((e.clientY - canvasBoundingRect.y) / canvasBoundingRect.height)
          );
          controls.mouseState = controls.toggleCell(x, y);
        }
      });

      const gui = new dat.GUI();

      const simulationFolder = gui.addFolder('Simulation');
      simulationFolder
        .add(controls, 'currentSimulationIndex', cellSpace.simulationNames)
        .name('Mode')
        .onChange(name => {
          controls.setSimulation(name);
        });
      simulationFolder.add(controls, 'run').name('Running');
      simulationFolder.add(controls, 'step').name('Step');

      const fillFolder = gui.addFolder('Fill');
      fillFolder.add(controls, 'fillDensity', 0.01, 1.0).name('Density');
      fillFolder.add(controls, 'fill').name('Fill');
      fillFolder.add(controls, 'clear').name('Clear');

      const interactionFolder = gui.addFolder('Interaction');
      controls.stateSelection = interactionFolder.add(controls, 'Cell', []);
      interactionFolder
        .add(controls, 'Brush Size', 2, 6, 1)

      simulationFolder.open();
      fillFolder.open();
      interactionFolder.open();

      controls.setSimulation('Water');

      const stats = new Stats();
      stats.showPanel(0);
      document.body.appendChild(stats.dom);

      function updateLoop() {
        stats.begin();
        if (controls.run) cellSpace.step();
        cellSpace.draw();
        stats.end();
        requestAnimationFrame(() => updateLoop());
      }

      updateLoop();
    </script>
  </body>
</html>
